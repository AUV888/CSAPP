## Problem

Assume variables x, f, and d are of type int, float, and double, respectively. Their values are arbitrary, except that neither f nor d equals +∞, −∞, or NaN. For each of the following C expressions, either argue that it will always be true (i.e., evaluate to 1) or give a value for the variables such that it is not true (i.e., evaluates to 0).

## A. `x == (int)(double) x`

**True**. Since double has more precision than int.

## B. `x == (int)(float) x`

**False**. The maximum odd number single percision float point could represent is $ 2^{24} - 1 $. Therefore, whenever $ x > 2^{24} - 1 $ and $ x $ is odd, `x != (int)(float) x`.

## C. `d == (double)(float) d`

**False**. Since double has more percision than float, converting double to float may cause percision lost. For example, when d is greater than the maximum number that float can represent, `d == (double)(float) d`.

## D. `f == (float)(double) f`

**True**. Since double has more precision than float.

## E. `f ==-(-f)`

**True**. Since -f just change the sign bit to its negation.

## F. `1.0/2 == 1/2.0`

**True**. Since both sides are float type, and are equivalent to 0.5.

## G. `d*d >= 0.0`

**True**. Whether d*d cause overflow or not, the sign bit of multiple is always 0, indicating the result >= 0.

## H. `(f+d) - f == d`

**False**. if $ f \gg d $, for example, $ f = 2^{125} $ and $ d = 2^{-1022} $, $ (f+d) - f = 0 $.
