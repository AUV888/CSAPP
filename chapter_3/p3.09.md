# Question

> Suppose we want to generate assembly code for the following C function:
>
> ```c
> long shift_left4_rightn(long x, long n)
> {
> 	x <<= 4;
> 	x >>= n;
> 	return x;
> }
> ```
>
> The code that follows is a portion of the assembly code that performs the
> actual shifts and leaves the final value in register %rax. Two key instructions
> have been omitted. Parameters x and n are stored in registers %rdi and %rsi,
> respectively.
>
> ```
> //long shift_left4_rightn(long x, long n)
> //x in %rdi, n in %rsi
>
> shift_left4_rightn:
> movq %rdi, %rax //Get x
> _______________ //x <<= 4
> movl %esi, %ecx //Get n (4 bytes)
> _______________ //x >>= n
> ret
> ```
>
> Fill in the missing instructions, following the annotations on the right. The
> right shift should be performed arithmetically.

# Solution

The solution generated by **GCC** is as follow.

```
movq %rdi, %rax   ; x -> %rax
salq $4, %rax     ; %rax = x << 4
movl %esi, %ecx   ; n -> %ecx (and zero-extends to %rcx)
sarq %cl, %rax    ; %rax = %rax >> n (using %cl)
ret
```

# Comments

We can easily come up with the assembly code  `x<<=4`, but the following 2 instructions may be confusing: Why should we first move n to %ecx, and why can't we just use `sarq %sil, %rax`, which looks like more efficient?

## (1) The rigid rule

Proposal to use `sarq %sil, %rax` to save an instruction is logical, but it is impossible due to a fundamental rule of the x86 instruction set.

This is the specific rule.

> **Architectural Rule:** In the x86 and x86-64 instruction set architecture (ISA), when a shift or rotate instruction uses a variable count (i.e., the number of bits to shift is determined by a register), that count **must** be located in the **`%cl`** register.

Because of this rigid rule:

* An instruction like `sarq %sil, %rax` is **invalid** and does not exist. An assembler will reject it.
* Since the shift count `n` is passed in `%rsi`, it **must** be moved into `%rcx` before the `sarq` instruction can be executed.

## (2) The optimization choice

Using `movl` is more efficient than using a smaller instruction like `movb`.

* **The Problem with `movb %sil, %cl`:** This instruction performs a "partial register write," modifying only the lowest 8 bits of the 64-bit `%rcx` register. On modern out-of-order CPUs, this can create a performance penalty (a "stall") because the CPU must merge the old value of the register with the new 8-bit value. This creates an unnecessary dependency on the previous value of `%rcx`.
* **The Advantage of `movl %esi, %ecx`:** According to the x86-64 architecture, any instruction that writes to a 32-bit register (like `%ecx`) also **automatically clears the upper 32 bits** of the corresponding 64-bit register (`%rcx`). This is not considered a partial write. It breaks the dependency on the old value of `%rcx`, allowing the CPU's pipeline to run more efficiently and avoid stalls. Furthermore, the `movl` instruction often has a shorter machine code encoding than `movq`, which is a minor benefit for code size and instruction cache efficiency.
* However, `movb %sil, %cl` is indeed legal and correct. It has the risk of **CPU Stall** and is not as fast as `movl %esi, %ecx`.
