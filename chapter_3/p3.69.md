## C Code

```c
typedef struct {
    int first;
    a_struct a[CNT];
    int last;
} b_struct;

void test(long i, b_struct *bp)
{
int n = bp->first + bp->last;
a_struct *ap = &bp->a[i];
ap->x[ap->idx] = n;
}
```

## Assembly Code

```assembly
test:
	mov 0x120(%rsi), %ecx           # last = bp +288
	add (%rsi), %ecx                # first
	lea (%rdi, %rdi, 4), %rax       # rax stores 5*i
	lea (%rsi, %rax, 8), %rax       # rax stores ap, where ap = bp + 40*i
	mov 0x8(%rax), %rdx             # rdx stores ap->idx, where ap->idx = *(ap+8) NOTE: ap has not +8(+first+align) yet!
	movslq %ecx, %rcx               # sign extension of ecx
	mov %rcx, 0x10(%rax, %rdx, 8)   # *(ap + 8 + 8 + 8*rdx) =n
	retq
```

## A. Find the value of CNT

According to the assembly code, last = bp + 288, where first occupies 4 bytes. However, due to alignment, the address of a_struct should be a multiple of 8, therefore, the space a_struct occupies should be 288 - 4 - 4 = 280 bytes. Comparing `a_struct *ap = &bp->a[i];` and `lea (%rsi, %rax, 8), %rax`, we found that ap = bp + 40 * i, indicating every a_struct occupies 40 bytes. Thus, the number of a_struct (i.e. CNT) should be 280 / 40 = 7.

## B. Complete declaration of a_struct

Observing `mov %rcx, 0x10(%rax, %rdx, 8)`, we found that rdx is multipled by 8, which means every element of array x accounts for 8 bytes, which may be singed long. Don't forget that ap has not added 8 (int first of b_struct and the unused 4-byte-space to align). Thus, +0x10 in this instruction could be written as + 8 (first & align)+ 8 (idx occupies). So, x is also signed long.

Completed declaration of a_struct in C are as follow:

```c
typedef struct{
    long idx;
    long x[4];
} a_struct;
```
