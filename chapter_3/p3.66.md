## C Prototype

```c
long sum_col(long n, long A[NR(n)][NC(n)], long j) {
    long i;
    long result = 0;
    for (i = 0; i < NR(n); i++)
        result += A[i][j];
    return result;
}
```

## Assembly Code & Comments

```asm
sum_col:
	leaq 1(, %rdi, 4), %r8      # r8 = 4n+1
	leaq (%rdi, %rdi, 2), %rax  # rax = 3n
	movq %rax, %rdi             # rdi = 3n
	testq %rax, %rax            # n <= 0, goto L4
	jle .L4
	salq $3, %r8                # r8 = 8*(4n+1)
	leaq (%rsi, %rdx, 8), %rcx  # rcx = A+8j, rcx is &A[0][j]
	movl $0, %eax               # result = 0
	movl $0, %edx               # i = 0
.L3:
	addq (%rcx), %rax           # result += A[i][j]
	addq $1, %rdx               # i++
	addq %r8, %rcx              # rcx += 8*(4n+1)
	cmpq %rdi, %rdx             # if j != 3n, goto L3
	jne .L3
	rep; ret
.L4:
	movl $0, %eax               # result = 0
	ret
```

## Solutions

From the comments of assembly code, we know that this loop (i.e. L3 in assembly code) stops when ` j == 3n `, thus ` NR(n) = 3n `.

Since array A is long type, and that everytime i++ followed by pointer adds 8*(4n+1), it's obvious that ` NR(n) = 4n+1 `